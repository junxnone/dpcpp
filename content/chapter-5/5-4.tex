The C++ exception features are designed to cleanly separate the point in a program where an error is detected from the point where it may be handled, and this concept fits very well with both synchronous and asynchronous errors in SYCL. Through the throw and catch mechanisms, a hierarchy of handlers can be defined which can be important in production applications.\par

Building an application that can handle errors in a consistent and reliable way requires a strategy up front and a resulting software architecture built for error management. C++ provides flexible tools to implement many alternative strategies, but such architecture is beyond the scope of this chapter. There are many books and other references devoted to this topic, so we encourage looking to them for full coverage of C++ error management strategies.\par

This said, error detection and reporting doesn’t always need to be production-scale. Errors in a program can be reliably detected and reported through minimal code if the goal is simply to detect errors during execution and to report them (but not necessarily to recover from them). The following sections cover first what happens if we ignore error handling and do nothing (the default behavior isn’t all that bad!), followed by recommended error reporting that is simple to implement in basic applications.\par

\hspace*{\fill} \par %插入空行
\textbf{Ignoring Error Handling}

C++ and SYCL are designed to tell us that something went wrong even when we don’t handle errors explicitly. The default result of unhandled synchronous or asynchronous errors is abnormal program termination which an operating system should tell us about. The following two examples mimic the behavior that will occur if we do not handle a synchronous and an asynchronous error, respectively.\par

Figure 5-4 shows the result of an unhandled C++ exception, which could be an unhandled SYCL synchronous error, for example. We can use this code to test what a particular operating system will report in such a case.\par

Figure 5-5 shows example output from std::terminate being called, which will be the result of an unhandled SYCL asynchronous error in our application. We can use this code to test what a particular operating system will report in such a case.\par

Although we probably should handle errors in our programs, since uncaught errors will be caught and the program terminated, we do not need to worry about a program silently failing!\par

\hspace*{\fill} \par %插入空行
Figure 5-4. Unhandled exception in C++
\begin{lstlisting}[caption={}]
#include <iostream>

class something_went_wrong {};

int main() {
	std::cout << "Hello\n";
	
	throw(something_went_wrong{});
}
/*
Example output in Linux:
Hello
terminate called after throwing an instance of 'something_went_wrong'

Aborted (core dumped)
*/
\end{lstlisting}

\hspace*{\fill} \par %插入空行
Figure 5-5. std::terminate is called when a SYCL asynchronous exception isn’t handled
\begin{lstlisting}[caption={}]
#include <iostream>

int main() {
	std::cout << "Hello\n";
	
	std::terminate();
}
/*
Example output in Linux:
Hello
terminate called without an active exception
Aborted (core dumped)
*/
\end{lstlisting}

\hspace*{\fill} \par %插入空行
\textbf{Synchronous Error Handling}

We keep this section very short because SYCL synchronous errors are just C++ exceptions. Most of the additional error mechanisms added in SYCL relate to asynchronous errors which we cover in the next section, but synchronous errors are important because implementations try to detect and report as many errors synchronously as possible, since they are easier to reason about and handle.\par

Synchronous errors defined by SYCL are a derived class from std::exception of type sycl::exception, which allows us to catch the SYCL errors specifically though a try-catch structure such as what we see in Figure 5-6.\par

\hspace*{\fill} \par %插入空行
Figure 5-6. Pattern to catch sycl::exception specifically
\begin{lstlisting}[caption={}]
try{
	// Do some SYCL work
} catch (sycl::exception &e) {
	// Do something to output or handle the exceptinon 
	std::cout << "Caught sync SYCL exception: " << e.what() << "\n";
	return 1;
} 
\end{lstlisting}

On top of the C++ error handling mechanisms, SYCL adds a sycl::exception type for the exceptions thrown by the runtime. Everything else is standard C++ exception handling, so will be familiar to most developers.\par

A slightly more complete example is provided in Figure 5-7, where additional classes of exception are handled, as well as the program being ended by returning from main().\par

\hspace*{\fill} \par %插入空行
Figure 5-7. Pattern to catch exceptions from a block of code
\begin{lstlisting}[caption={}]
try{
	buffer<int> B{ range{16} };
	// ERROR: Create sub-buffer larger than size of parent buffer
	// An exception is thrown from within the buffer constructor
	buffer<int> B2(B, id{8}, range{16});
	
} catch (sycl::exception &e) {
	// Do something to output or handle the exception 
	std::cout << "Caught sync SYCL exception: " << e.what() << "\n";
	return 1;
} catch (std::exception &e) {
	std::cout << "Caught std exception: " << e.what() << "\n";
	return 2;
} catch (...) {
	std::cout << "Caught unknown exception\n";
	return 3;
}
return 0;

/*
Example output:
Caught sync SYCL exception: Requested sub-buffer size exceeds the size of 
the parent buffer -30 (CL_INVALID_VALUE)
*/
\end{lstlisting}

\hspace*{\fill} \par %插入空行
\textbf{Asynchronous Error Handling}

Asynchronous errors are detected by the SYCL runtime (or an underlying backend), and the errors occur independently of execution of commands in the host program. The errors are stored in lists internal to the SYCL runtime and only released for processing at specific points that the programmer can control. There are two topics that we need to discuss to cover handling of asynchronous errors:\par

\begin{enumerate}
	\item \textbf{The asynchronous handler} that is invoked when there are outstanding asynchronous errors to process
	\item \textbf{When} the asynchronous handler is invoked
\end{enumerate}

\hspace*{\fill} \par %插入空行
\textbf{The Asynchronous Handler}

The asynchronous handler is a function that the application defines, which is registered with SYCL contexts and/or queues. At the times defined by the next section, if there are any unprocessed asynchronous exceptions that are available to be handled, then the asynchronous handler is invoked by the SYCL runtime and passed a list of these exceptions.\par

The asynchronous handler is passed to a context or queue constructor as a std::function and can be defined in ways such as a regular function, lambda, or functor, depending on our preference. The handler must accept a sycl::exception\_list argument, such as in the example handler shown in Figure 5-8.\par

\hspace*{\fill} \par %插入空行
Figure 5-8. Example asynchronous handler implementation defined as a lambda
\begin{lstlisting}[caption={}]
// Our simple asynchronous handler function
auto handle_async_error = [](exception_list elist) {
	for (auto &e : elist) {
		try{ std::rethrow_exception(e); }
		catch ( sycl::exception& e ) {
			std::cout << "ASYNC EXCEPTION!!\n";
			std::cout << e.what() << "\n";
		}
	}
};
\end{lstlisting}

In Figure 5-8, the std::rethrow\_exception followed by catch of a specific exception type provides filtering of the type of exception, in this case to the only sycl::exception. We can also use alternative filtering approaches in C++ or just choose to handle all exceptions regardless of the type.\par

The handler is associated with a queue or context (low-level detail covered more in Chapter 6) at construction time. For example, to register the handler defined in Figure 5-8 with a queue that we are creating, we could write\par

queue my\_queue{ gpu\_selector{}, handle\_async\_error };\par

Likewise, to register the handler defined in Figure 5-8 with a context that we are creating, we could write\par

context my\_context{ handle\_async\_error };\par

Most applications do not need contexts to be explicitly created or managed (they are created behind the scenes for us automatically), so if an asynchronous handler is going to be used, most developers should associate such handlers with queues that are being constructed for specific devices (and not explicit contexts).\par

\begin{tcolorbox}[colback=red!5!white,colframe=red!75!black]
In defining asynchronous handlers, most developers should define them on queues unless already explicitly managing contexts for other reasons.
\end{tcolorbox}

If an asynchronous handler is not defined for a queue or the queue’s parent context and an asynchronous error occurs on that queue (or in the context) that must be processed, then the default asynchronous handler is invoked. The default handler operates as if it was coded as shown in Figure 5-9.\par

\hspace*{\fill} \par %插入空行
Figure 5-9. Example of how the default asynchronous handler behaves
\begin{lstlisting}[caption={}]
// Our simple asynchronous handler function
auto handle_async_error = [](exception_list elist) {
	for (auto &e : elist) {
		try{ std::rethrow_exception(e); }
		catch ( sycl::exception& e ) {
			// Print information about the asynchronous exception
		}
	}

	// Terminate abnormally to make clear to user
	// that something unhandled happened
	std::terminate();
};
\end{lstlisting}

The default handler should display some information to the user on any errors in the exception list and then will terminate the application abnormally, which should also cause the operating system to report that termination was abnormal.\par

What we put within an asynchronous handler is up to us. It can range from logging of an error to application termination to recovery of the error condition so that an application can continue executing normally. The common case is to report any details of the error available by calling sycl::exception::what(), followed by termination of the application.\par

Although it’s up to us to decide what an asynchronous handler does internally, a common mistake is to print an error message (that may be missed in the noise of other messages from the program), followed by completion of the handler function. Unless we have error management principles in place that allow us to recover known program state and to be confident that it’s safe to continue execution, we should consider terminating the application within our asynchronous handler function(s). This reduces the chance that incorrect results will appear from a program where an error was detected, but where the application was inadvertently allowed to continue with execution regardless. In many programs, abnormal termination is the preferred result once we have experienced asynchronous exceptions.\par

\begin{tcolorbox}[colback=red!5!white,colframe=red!75!black]
Consider terminating applications within an asynchronous handler, after outputting information about the error, if comprehensive error recovery and management mechanisms are not in place.
\end{tcolorbox}

\hspace*{\fill} \par %插入空行
\textbf{Invocation of the Handler}

The asynchronous handler is called by the runtime at specific times. Errors aren’t reported immediately as they occur because management of errors and safe application programming (particularly multithreaded) would become more difficult and expensive if that was the case. The asynchronous handler is instead called at the following very specific times:\par

\begin{enumerate}
	\item When the host program calls \textbf{queue::throw\_asynchronous()} on a specific queue
	\item When the host program calls \textbf{queue::wait\_and\_throw()} on a specific queue
	\item When the host program calls \textbf{event::wait\_and\_throw()} on a specific event
	\item When a \textbf{queue} is destroyed
	\item When a \textbf{context} is destroyed
\end{enumerate}

Methods 1–3 provide a mechanism for a host program to control when asynchronous exceptions are handled, so that thread safety and other details specific to an application can be managed. They effectively provide controlled points at which asynchronous exceptions enter the host program control flow and can be processed almost as if they were synchronous errors.\par

If a user doesn’t explicitly call one of the methods 1–3, then asynchronous errors are commonly reported during program teardown when queues and contexts are destroyed. This is often enough to signal to a user that something went wrong and that program results shouldn’t be trusted.\par

Relying on error detection during program teardown doesn’t work in all cases, though. For example, if a program will only terminate when some algorithm convergence criteria are achieved and if those criteria are only achievable by successful execution of device kernels, then an asynchronous exception may signal that the algorithm will never converge and begin the teardown (where the error would be noticed). In these cases, and also in production applications where more complete error handling strategies are in place, it makes sense to invoke throw\_asynchronous() or wait\_and\_throw() at regular and controlled points in the program (e.g., before checking whether algorithm convergence has occurred).\par



















