To get the most out of thread-level parallelism and SIMD vector-level parallelism on CPUs, we need to keep the following goals in mind:\par

\begin{itemize}
	\item Be familiar with all types of DPC++ parallelism and the 	underlying CPU architectures we wish to target
	\item Exploit the right amount of parallelism, not more and not less, at a thread level that best matches hardware resources. Use vendor tooling, such as analyzers and profilers, to help guide our tuning work to achieve this.
	\item Be mindful of thread affinity and memory first touch impact on program performance.
	\item Design data structures with a data layout, alignment, and data width such that the most frequently executed calculations can access memory in a SIMD-friendly manner with maximum SIMD parallelism.
	\item Be mindful of balancing the cost of masking vs. code branches.
	\item Use a clear programming style that minimizes potential memory aliasing and side effects.
	\item Be aware of the scalability limitations of using vector types and interfaces. If a compiler implementation maps them to hardware SIMD instructions, a fixed vector size may not match the SIMD width of SIMD registers well across multiple generations of CPUs and 
	CPUs from different vendors.
\end{itemize}






\newpage