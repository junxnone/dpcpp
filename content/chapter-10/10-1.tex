Before we dive into the details, let’s start with a summary of why there are three ways to define a kernel and the advantages and disadvantages of each method. A useful summary is given in Figure 10-1.\par

Bear in mind that a kernel is used to express a unit of computation and that many instances of a kernel will usually execute in parallel on an accelerator. SYCL supports multiple ways to express a kernel to integrate naturally and seamlessly into a variety of codebases while executing efficiently on a wide diversity of accelerator types.\par

\hspace*{\fill} \par %插入空行
Figure 10-1. Three ways to represent a kernel
\begin{table}[]
	\begin{tabular}{|l|l|}
		\hline
		\textbf{\begin{tabular}[c]{@{}l@{}}Kernel\\ Representation\end{tabular}}                         & \textbf{Description}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \\ \hline
		\textbf{Lambda Expression}                                                                       & \begin{tabular}[c]{@{}l@{}}Pros:\\ ·Lambda expressions are a concise way to represent a kernel right\\   where it is used.\\ ·Lambda expressions are a familiar way to represent kernel-like\\   operateions in modern C++ codebases.\\ ·Lambda capture rules automatically pass data to kernels.\\ \\ Cons:\\ ·Kernels represented as lambda expressions cannot be templated,\\   cannot easily be reused, and cannot be shipped as a library.\\ ·Thel lambda syntax may be unfamiliar to some C++ codebases.\end{tabular}                                                                                                                                                                                                                                           \\ \hline
		\textbf{\begin{tabular}[c]{@{}l@{}}Named Function Object\\ (Functor)\end{tabular}}               & \begin{tabular}[c]{@{}l@{}}Pros:\\ ·Functors can be templated, resued, and shipped as a part of a library,\\   just like any other C++ class.\\ ·Functors provide more control over the data that gets passed into a kernel.\\ \\ Cons:\\ ·Kernels represented as functors require more code than kernels\\   represented as lambda expressions.\\ ·Kerenl arguments must be explicitly passed to functors and are not\\   captured automatically.\end{tabular}                                                                                                                                                                                                                                                                                                       \\ \hline
		\textbf{\begin{tabular}[c]{@{}l@{}}Interoperability with Other\\ Languages or APIs\end{tabular}} & \begin{tabular}[c]{@{}l@{}}Pros:\\ ·Enables re-use of previously written kernels or libraries.\\ ·Enables large application codebases to incrementally add support for SYCL.\\ ·Kernel languages from other APIs may support features that have not\\   been added or are difficult to express with SYCL.\\ \\ Cons:\\ ·Interoperability is an optional feature that may not be supported by\\   all SYCL implementations or by all SYCL devices in an implementation.\\ ·Kernels written in other APIs are not compiled by the SYCL device\\   compiler, which may limit compile-time syntax checking, type\\   checking for kernelarguments, and optimization opportunities.\\ ·Kernels written in other APIs may not support the latest C++ features.\end{tabular} \\ \hline
	\end{tabular}
\end{table}









